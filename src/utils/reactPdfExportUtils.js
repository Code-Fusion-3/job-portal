import React from 'react';
import { Document, Page, Text, View, StyleSheet, pdf } from '@react-pdf/renderer';

// Create styles for the PDF
const createStyles = () => StyleSheet.create({
  page: {
    flexDirection: 'column',
    backgroundColor: '#ffffff',
    padding: 15,
    fontSize: 9,
  },
  header: {
    marginBottom: 10,
    borderBottom: '2 solid #3b82f6',
    paddingBottom: 5,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#1f2937',
    marginBottom: 2,
  },
  subtitle: {
    fontSize: 16,
    color: '#6b7280',
    marginBottom: 2,
  },
  dateRange: {
    fontSize: 12,
    color: '#9ca3af',
    marginBottom: 6,
  },
  table: {
    display: 'table',
    width: 'auto',
    borderStyle: 'solid',
    borderWidth: 1,
    borderRightWidth: 0,
    borderBottomWidth: 0,
    borderColor: '#e5e7eb',
  },
  tableRow: {
    margin: 'auto',
    flexDirection: 'row',
  },
  tableColHeader: {
    width: 'auto',
    borderStyle: 'solid',
    borderWidth: 1,
    borderLeftWidth: 0,
    borderTopWidth: 0,
    borderColor: '#3b82f6',
    backgroundColor: '#3b82f6',
    padding: 1,
    minHeight: 18,
    justifyContent: 'center',
    alignItems: 'center',
  },
  tableCol: {
    width: '1',
    borderStyle: 'solid',
    borderWidth: 1,
    borderLeftWidth: 0,
    borderTopWidth: 0,
    borderColor: '#e5e7eb',
    padding: 1,
    minHeight: 5,
    justifyContent: 'center',
    alignItems: 'center',
  },
  tableCellHeader: {
    margin: '2',
    fontSize: 11,
    fontWeight: 'bold',
    color: '#ffffff',
    textAlign: 'center',
  },
  tableCell: {
    margin: '2',
    fontSize: 9,
    color: '#1f2937',
    textAlign: 'center',
  },
  tableCellLeft: {
    margin: '2',
    fontSize: 9,
    color: '#1f2937',
    textAlign: 'left',
  },
  footer: {
    position: 'absolute',
    bottom: 15,
    left: 15,
    right: 15,
    textAlign: 'center',
    color: '#6b7280',
    fontSize: 8,
    borderTop: '1 solid #e5e7eb',
    paddingTop: 5,
  },
  pageNumber: {
    position: 'absolute',
    bottom: 15,
    right: 15,
    color: '#6b7280',
    fontSize: 8,
  },
  alternateRow: {
    backgroundColor: '#f9fafb',
  },
});

/**
 * Create PDF Document Component
 */
const createPDFDocument = (reportType, tableData, columns, options) => {
  const styles = createStyles();
  const title = options.title || getReportTitle(reportType);
  const subtitle = options.subtitle || `Comprehensive data table for ${title.toLowerCase()}`;
  const dateRange = options.dateRange || `Export Date: ${new Date().toLocaleDateString()}`;

  // Get merged column configuration for this report type
  const mergedColumns = getMergedColumns(reportType, columns);
  
  return React.createElement(Document, {}, 
    React.createElement(Page, { 
      size: "A4", 
      orientation: "landscape", 
      style: styles.page 
    }, [
      // Header
      React.createElement(View, { key: 'header', style: styles.header }, [
        React.createElement(Text, { key: 'title', style: styles.title }, 'Job Portal System'),
        React.createElement(Text, { key: 'subtitle', style: styles.subtitle }, title),
        React.createElement(Text, { key: 'dateRange', style: styles.dateRange }, dateRange)
      ]),

      // Table
      React.createElement(View, { key: 'table', style: styles.table }, [
        // Table Header
        React.createElement(View, { key: 'header-row', style: styles.tableRow }, 
          mergedColumns.map((col, index) => 
            React.createElement(View, { 
              key: `header-${index}`, 
              style: [styles.tableColHeader, { width: getColumnWidth(col.key, reportType) }] 
            }, 
              React.createElement(Text, { style: styles.tableCellHeader }, col.label)
            )
          )
        ),

        // Table Body
        ...tableData.map((row, rowIndex) => 
          React.createElement(View, { 
            key: `row-${rowIndex}`, 
            style: [
              styles.tableRow, 
              rowIndex % 2 === 1 ? styles.alternateRow : {}
            ] 
          }, 
            mergedColumns.map((col, colIndex) => 
              React.createElement(View, { 
                key: `cell-${rowIndex}-${colIndex}`, 
                style: [styles.tableCol, { width: getColumnWidth(col.key, reportType) }] 
              }, 
                React.createElement(Text, { 
                  style: getCellStyle(col.key) 
                }, 
                  formatMergedCellValue(row, col, reportType)
                )
              )
            )
          )
        )
      ]),

      // Footer
      React.createElement(View, { key: 'footer', style: styles.footer }, 
        React.createElement(Text, {}, `Generated by Job Portal System â€¢ Total records: ${tableData.length}`)
      ),

      // Page Number
      React.createElement(Text, { 
        key: 'pageNumber', 
        style: styles.pageNumber,
        render: ({ pageNumber, totalPages }) => `Page ${pageNumber} of ${totalPages}`
      })
    ])
  );
};

/**
 * Generate PDF report using react-pdf for better styling and alignment
 */
export const generateTablePDF = async (reportType, tableData, columns, options = {}) => {
  try {
    if (!tableData || !Array.isArray(tableData) || tableData.length === 0) {
      throw new Error('No table data provided');
    }

    if (!columns || !Array.isArray(columns) || columns.length === 0) {
      throw new Error('No columns provided');
    }

    // Create the PDF document component
    const pdfDocument = createPDFDocument(reportType, tableData, columns, options);

    // Generate PDF blob
    const blob = await pdf(pdfDocument).toBlob();
    
    return blob;
  } catch (error) {
    console.error('Error generating react-pdf:', error);
    throw new Error(`Failed to generate PDF report: ${error.message}`);
  }
};

/**
 * Get optimal column width based on column type and report type
 */
const getColumnWidth = (columnKey, reportType) => {
  // Special handling for merged columns
  if (columnKey === 'jobseeker_info') {
    return '40%'; // Wider for name, email, phone, location
  }
  
  if (columnKey === 'employer_info') {
    return '30%'; // Wider for employer name, company, email
  }
  
  if (columnKey === 'candidate_info') {
    return '30%'; // Wider for candidate name, email, contact
  }
  
  if (columnKey === 'job_details') {
    return '30%'; // Wider for category, monthly rate, status, and priority
  }
  
  // Regular column widths
  const widthMap = {
    'name': '20%',
    'email': '25%',
    'phone': '15%',
    'location': '20%',
    'category': '20%',
    'experience': '15%',
    'status': '12%',
    'priority': '12%',
    'demand': '12%',
    'count': '10%',
    'percentage': '10%',
    'createdAt': '15%',
    'registeredAt': '15%',
    'employerName': '20%',
    'companyName': '20%',
    'candidateName': '20%',
    'candidateEmail': '20%',
    'candidateContact': '15%',
    'position': '20%',
    'monthlyRate': '15%',
    'contactEmail': '20%'
  };
  
  return widthMap[columnKey] || '15%';
};

/**
 * Get appropriate cell style based on column type
 */
const getCellStyle = (columnKey) => {
  // Left-align text for merged info columns and name fields, center for others
  if (['jobseeker_info', 'employer_info', 'candidate_info', 'job_details', 'name', 'email', 'location', 'category', 'position', 'companyName', 'employerName', 'candidateName', 'candidateEmail'].includes(columnKey)) {
    return { textAlign: 'left' };
  }
  return { textAlign: 'center' };
};

/**
 * Format cell value for display
 */
const formatCellValue = (value, columnKey) => {
  if (!value && value !== 0) return 'N/A';
  
  // Handle special formatting
  if (columnKey === 'status' || columnKey === 'priority' || columnKey === 'demand') {
    return formatStatusValue(value);
  }
  
  if (columnKey === 'percentage') {
    return `${value}%`;
  }
  
  if (columnKey === 'monthlyRate' && value !== 'Not specified') {
    return value;
  }
  
  // Handle long text by truncating
  if (typeof value === 'string' && value.length > 30) {
    return value.substring(0, 27) + '...';
  }
  
  return value;
};

/**
 * Format status values for better readability
 */
const formatStatusValue = (value) => {
  if (!value) return 'N/A';
  
  const statusMap = {
    'Active': 'Active',
    'Inactive': 'Inactive',
    'pending': 'Pending',
    'in_progress': 'In Progress',
    'completed': 'Completed',
    'urgent': 'Urgent',
    'high': 'High',
    'normal': 'Normal',
    'low': 'Low',
    'High': 'High',
    'Medium': 'Medium',
    'Low': 'Low'
  };
  
  return statusMap[value] || value;
};

/**
 * Get report title for display
 */
const getReportTitle = (reportType) => {
  const titles = {
    'job-seekers': 'Job Seekers Report',
    'employer-requests': 'Employer Requests Report',
    'categories': 'Job Categories Report',
    'locations': 'Location Distribution Report',
    'skills': 'Skills Analysis Report'
  };
  
  return titles[reportType] || 'Table Report';
};

/**
 * Get merged column configuration for a specific report type
 */
const getMergedColumns = (reportType, originalColumns) => {
  if (reportType === 'job-seekers') {
    return [
      { 
        key: 'jobseeker_info', 
        label: 'Job Seeker Info',
        subColumns: ['name', 'email', 'phone', 'location']
      },
      { 
        key: 'job_details', 
        label: 'Job Details',
        subColumns: ['category', 'experience']
      },
      { 
        key: 'registeredAt', 
        label: 'Registration Date',
        subColumns: ['registeredAt']
      },
      { 
        key: 'status', 
        label: 'Status',
        subColumns: ['status']
      }
    ];
  }
  
  if (reportType === 'employer-requests') {
    return [
      { 
        key: 'employer_info', 
        label: 'Employer Info',
        subColumns: ['employerName', 'companyName', 'employerEmail']
      },
      { 
        key: 'candidate_info', 
        label: 'Candidate Info',
        subColumns: ['candidateName', 'candidateEmail', 'candidateContact']
      },
      { 
        key: 'job_details', 
        label: 'Job Details',
        subColumns: ['category', 'monthlyRate', 'status', 'priority']
      },
      { 
        key: 'createdAt', 
        label: 'Request Date',
        subColumns: ['createdAt']
      }
    ];
  }
  
  if (reportType === 'categories') {
    return [
      { 
        key: 'category', 
        label: 'Category',
        subColumns: ['category']
      },
      { 
        key: 'count', 
        label: 'Count',
        subColumns: ['count']
      },
      { 
        key: 'percentage', 
        label: 'Percentage',
        subColumns: ['percentage']
      }
    ];
  }
  
  if (reportType === 'locations') {
    return [
      { 
        key: 'location', 
        label: 'Location',
        subColumns: ['location']
      },
      { 
        key: 'count', 
        label: 'Count',
        subColumns: ['count']
      },
      { 
        key: 'percentage', 
        label: 'Percentage',
        subColumns: ['percentage']
      }
    ];
  }
  
  if (reportType === 'skills') {
    return [
      { 
        key: 'skill', 
        label: 'Skill',
        subColumns: ['skill']
      },
      { 
        key: 'count', 
        label: 'Count',
        subColumns: ['count']
      },
      { 
        key: 'percentage', 
        label: 'Percentage',
        subColumns: ['percentage']
      }
    ];
  }
  
  // Return original columns if no specific config
  return originalColumns.map(col => ({
    key: col.key,
    label: col.label,
    subColumns: [col.key]
  }));
};

/**
 * Format merged cell value for display
 */
const formatMergedCellValue = (row, col, reportType) => {
  if (!col.subColumns || col.subColumns.length === 1) {
    // Single column, format normally
    const key = col.subColumns ? col.subColumns[0] : col.key;
    return formatCellValue(row[key], key);
  }

  // Multiple sub-columns, format them together
  const values = col.subColumns.map(subKey => {
    const value = row[subKey];
    if (!value || value === 'Not provided' || value === 'Not specified' || value === 'Unknown') {
      return null;
    }
    return value;
  }).filter(Boolean);

  if (values.length === 0) {
    return 'N/A';
  }

  if (values.length === 1) {
    return values[0];
  }

  // For merged columns, create a formatted display
  if (col.key === 'jobseeker_info') {
    return `${values[0]}\n${values[1]}\n${values[2]}\n${values[3]}`;
  }

  if (col.key === 'employer_info') {
    return `${values[0]}\n${values[1]}\n${values[2] || 'N/A'}`;
  }

  if (col.key === 'candidate_info') {
    return `${values[0]}\n${values[1]}\n${values[2] || 'N/A'}`;
  }

  if (col.key === 'job_details') {
    if (reportType === 'job-seekers') {
      return `${values[0]}\n${values[1]}`;
    } else if (reportType === 'employer-requests') {
      return `${values[0]}\n${values[1]}\n${values[2]}\n${values[3]}`;
    }
    return values.join('\n');
  }

  // Default: join with line breaks
  return values.join('\n');
};

/**
 * Export PDF blob to file
 */
export const exportPDFToFile = async (blob, filename) => {
  try {
    // Create download link
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.visibility = 'hidden';
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up
    URL.revokeObjectURL(url);
    
    return true;
  } catch (error) {
    console.error('Error saving PDF:', error);
    return false;
  }
};



/**
 * Export data as CSV file
 */
export const exportToCSV = (tableData, columns, filename) => {
  try {
    // Create CSV header
    const headers = columns.map(col => col.label).join(',');
    
    // Create CSV rows
    const rows = tableData.map(row => {
      return columns.map(col => {
        const value = row[col.key];
        // Escape commas and quotes in CSV
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value || '';
      }).join(',');
    });
    
    // Combine header and rows
    const csvContent = [headers, ...rows].join('\n');
    
    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    return true;
  } catch (error) {
    console.error('Error exporting CSV:', error);
    return false;
  }
};

/**
 * Export data as Excel file (HTML format)
 */
export const exportToExcel = (tableData, columns, filename) => {
  try {
    // Create HTML table
    let html = '<table border="1">';
    
    // Add header row
    html += '<tr>';
    columns.forEach(col => {
      html += `<th style="background-color: #3b82f6; color: white; padding: 8px; text-align: center; font-weight: bold;">${col.label}</th>`;
    });
    html += '</tr>';
    
    // Add data rows
    tableData.forEach(row => {
      html += '<tr>';
      columns.forEach(col => {
        const value = row[col.key] || '';
        html += `<td style="padding: 6px; border: 1px solid #e5e7eb;">${value}</td>`;
      });
      html += '</tr>';
    });
    
    html += '</table>';
    
    // Create and download file
    const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', filename.replace('.xlsx', '.html'));
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    return true;
  } catch (error) {
    console.error('Error exporting Excel:', error);
    return false;
  }
};
